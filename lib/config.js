const dotProp = require('dot-prop')

/**
 * The cfg object is entirely optional. It can be used to
 * provide initial values or override the stored values.
 * 
 * Any options not passed will be read from stored configuration, 
 * generated, assumed, etc. If an option cannot be assumed and 
 * interactive is set to False or the user is not in a CLI 
 * environment, an error will be thrown.
 * 
 * Example config object:
 * {
 *   interactive: true,
 *   persist: true,
 *   basePath: null,
 *   token: '[hidden]',
 *   gistId: '[hidden]',
 *   lastSaved: 1498793624480,
 *   lastSynced: 1498793624480
 * }
 * 
 * Explanations:
 *   configFiles: A directory, file, or array of files, to sync with the private gist
 *   interactive: whether or not to allow gist-config to ask the user
 *     for any missing information at runtime. This might not work if the
 *     user is not in a CLI environment.
 *   persist: whether or not to save the configuration to disk. This occurs
 *     both when calling the configure() function and when running a sync
 *     operation itself--even an upload stores a timestamp for comparison.
 *   spinner: whether or not to show a CLI spinner while tasks are running. Spinner 
 *     should be disabled automatically if not in a CLI environment, so this usually 
 *     doesn't need to be set.
 *   basePath: if provided, this prefix will be removed from any paths uploaded to 
 *     the gist, and added back to any paths downloaded from the gist. If not provided,
 *     paths are assumed absolute.
 *   token: A token generated by the user. If store is true, it will 
 *     be stored for future runs automatically. If false, it should be 
 *     provided every time the library is loaded.
 *   gistId: Can be provided, but usually this is auto-generated. The exception
 *     is when store is false, you should store the returned gist id that is 
 *     used initially, so that you can pass it back in for future runs.
 *   lastSaved: A date indicating when your configuration was last updated.
 *     This is used for comparison to ensure you aren't unintentionally noverwriting
 *     newer configuration either locally or in the cloud. This value will 
 *     be set to the time of the last sync download operation if it's not explcitely
 *     set, allowing that date to be used next time. If you update your configuration, 
 *     it's best to store a timestamp and pass it in here when loading the library 
 *     to be explicit.
 *   lastSynced: Similar to gistId, this should only be passed in on subsequent 
 *     sync operations if store is set to false, and it should be a timestamp 
 *     returned from the previous sync operation.
 * 
 * @param {*} userConfig 
 */
var config = getDefaults()

module.exports = {
    get: (key, defaultValue) => {
        if (!key) {
            return config
        }

        return dotProp.get(config, key, defaultValue)
    },
    set: (key, value) => {
        if (typeof value === 'undefined') {
            config = Object.assign(getDefaults(), key)
        } else {
            dotProp.set(config, key, value)
        }

        return module.exports
    },
    delete: (key) => {
        if (typeof key === 'undefined') {
            config = getDefaults()
        } else {
            var defaults = getDefaults()
            config[key] = defaults[key]
        }
    }
}

function getDefaults() {
    return {
        interactive: true,
        basePath: null,
        spinner: true,
        token: '',
        gistId: '',
        lastSaved: + new Date(),
        lastSynced: null,
        initialized: false
    }
}
